import { describe, it, expect, vi, beforeEach } from 'vitest'
import { render, screen, fireEvent, waitFor } from '@testing-library/react'
import { ReviewsList } from '../ReviewsList'
import type { Review } from '@/types/domain'

// Mock AuthContext
const mockUseAuth = vi.fn();
vi.mock('@/context/AuthContext', () => ({
  useAuth: () => mockUseAuth()
}))

// Mock the API service - define outside vi.mock to avoid hoisting issues
vi.mock('@/services/api', () => ({
  default: {
    reviews: {
      list: vi.fn(),
      update: vi.fn(),
      delete: vi.fn(),
    }
  }
}))

// Mock toast
const mockToast = {
  success: vi.fn(),
  error: vi.fn()
};
vi.mock('react-hot-toast', () => ({
  default: mockToast
}))

// Mock Button component
vi.mock('@/components/ui/Button', () => ({
  Button: ({ children, onClick, variant }: { children: React.ReactNode; onClick?: () => void; variant?: string }) => 
    <button onClick={onClick} data-variant={variant}>{children}</button>
}))

// Mock RatingStars component  
vi.mock('@/components/ui/RatingStars', () => ({
  RatingStars: ({ value }: { value: number }) => <div data-testid="rating-stars">{value} stars</div>
}))

describe('ReviewsList Component', () => {
  const mockReviews: Review[] = [
    {
      id: '1',
      bookId: '1',
      userId: '1',
      rating: 5,
      content: 'Great book!',
      createdAt: '2023-01-01T00:00:00Z',
      user: {
        id: '1',
        name: 'Test User',
        email: 'test@example.com'
      }
    },
    {
      id: '2',
      bookId: '1',
      userId: '2',
      rating: 4,
      content: 'Good read',
      createdAt: '2023-01-02T00:00:00Z',
      user: {
        id: '2',
        name: 'Other User',
        email: 'other@example.com'
      }
    }
  ]

  const defaultProps = {
    reviews: mockReviews,
    onReload: vi.fn(),
    onUpdate: vi.fn(),
    onDelete: vi.fn(),
  }

  it('renders list of reviews', () => {
    render(<ReviewsList {...defaultProps} />)
    
    expect(screen.getByText('Great book!')).toBeInTheDocument()
    expect(screen.getByText('Good read')).toBeInTheDocument()
  })

  it('displays review ratings', () => {
    render(<ReviewsList {...defaultProps} />)
    
    expect(screen.getByText('Test User')).toBeInTheDocument()
    expect(screen.getByText('Other User')).toBeInTheDocument()
  })

  it('shows empty state when no reviews', () => {
    render(<ReviewsList {...defaultProps} reviews={[]} />)
    
    expect(screen.getByText('No reviews yet.')).toBeInTheDocument()
  })

  it('applies custom className', () => {
    const { container } = render(
      <ReviewsList {...defaultProps} reviews={[]} className="custom-class" />
    )
    
    expect(container.firstChild).toHaveClass('custom-class')
  })

  it('renders reviews with proper structure', () => {
    const { container } = render(<ReviewsList {...defaultProps} />)
    
    // Should have review items
    const reviewItems = container.querySelectorAll('[class*="space-y"]')
    expect(reviewItems.length).toBeGreaterThan(0)
  })

  it('displays user information for each review', () => {
    const { container } = render(<ReviewsList {...defaultProps} />)
    
    // Should have review content
    const reviewContent = container.querySelectorAll('[class*="text"]')
    expect(reviewContent.length).toBeGreaterThan(0)
  })

  describe('User Authentication and Actions', () => {
    beforeEach(() => {
      vi.clearAllMocks()
      mockUseAuth.mockReturnValue({
        user: { id: '1', name: 'Test User', email: 'test@example.com' }
      })
    })

    it('shows edit and delete buttons for user own reviews', () => {
      render(<ReviewsList {...defaultProps} />)
      
      // Should show edit/delete for user's own review (id: '1')
      const editButtons = screen.getAllByText('Edit')
      const deleteButtons = screen.getAllByText('Delete')
      
      expect(editButtons.length).toBeGreaterThan(0)
      expect(deleteButtons.length).toBeGreaterThan(0)
    })

    it('handles edit mode activation', async () => {
      render(<ReviewsList {...defaultProps} />)
      
      const editButton = screen.getAllByText('Edit')[0]
      fireEvent.click(editButton)

      await waitFor(() => {
        expect(screen.getByText('Save')).toBeInTheDocument()
        expect(screen.getByText('Cancel')).toBeInTheDocument()
      })
    })

    it('handles edit cancellation', async () => {
      render(<ReviewsList {...defaultProps} />)
      
      const editButton = screen.getAllByText('Edit')[0]
      fireEvent.click(editButton)

      await waitFor(() => {
        const cancelButton = screen.getByText('Cancel')
        fireEvent.click(cancelButton)
      })

      expect(screen.getByText('Edit')).toBeInTheDocument()
    })

    it('handles review update', async () => {
      mockApi.put.mockResolvedValue({ data: { id: '1', content: 'Updated content' } })
      
      render(<ReviewsList {...defaultProps} />)
      
      const editButton = screen.getAllByText('Edit')[0]
      fireEvent.click(editButton)

      await waitFor(() => {
        const saveButton = screen.getByText('Save')
        fireEvent.click(saveButton)
      })

      expect(mockApi.put).toHaveBeenCalled()
      expect(mockToast.success).toHaveBeenCalledWith('Review updated')
    })

    it('handles review deletion', async () => {
      mockApi.delete.mockResolvedValue({})
      
      render(<ReviewsList {...defaultProps} />)
      
      const deleteButton = screen.getAllByText('Delete')[0]
      fireEvent.click(deleteButton)

      await waitFor(() => {
        expect(mockApi.delete).toHaveBeenCalled()
        expect(mockToast.success).toHaveBeenCalledWith('Review deleted')
      })
    })

    it('handles update errors', async () => {
      mockApi.put.mockRejectedValue(new Error('Update failed'))
      
      render(<ReviewsList {...defaultProps} />)
      
      const editButton = screen.getAllByText('Edit')[0]
      fireEvent.click(editButton)

      await waitFor(() => {
        const saveButton = screen.getByText('Save')
        fireEvent.click(saveButton)
      })

      expect(mockToast.error).toHaveBeenCalledWith('Failed to update review')
    })

    it('handles delete errors', async () => {
      mockApi.delete.mockRejectedValue(new Error('Delete failed'))
      
      render(<ReviewsList {...defaultProps} />)
      
      const deleteButton = screen.getAllByText('Delete')[0]
      fireEvent.click(deleteButton)

      await waitFor(() => {
        expect(mockToast.error).toHaveBeenCalledWith('Failed to delete review')
      })
    })

    it('calls onUpdate when provided', async () => {
      const mockOnUpdate = vi.fn()
      mockApi.put.mockResolvedValue({ data: { id: '1', content: 'Updated' } })
      
      render(<ReviewsList {...defaultProps} onUpdate={mockOnUpdate} />)
      
      const editButton = screen.getAllByText('Edit')[0]
      fireEvent.click(editButton)

      await waitFor(() => {
        const saveButton = screen.getByText('Save')
        fireEvent.click(saveButton)
      })

      expect(mockOnUpdate).toHaveBeenCalled()
    })

    it('calls onDelete when provided', async () => {
      const mockOnDelete = vi.fn()
      mockApi.delete.mockResolvedValue({})
      
      render(<ReviewsList {...defaultProps} onDelete={mockOnDelete} />)
      
      const deleteButton = screen.getAllByText('Delete')[0]
      fireEvent.click(deleteButton)

      await waitFor(() => {
        expect(mockOnDelete).toHaveBeenCalledWith('1')
      })
    })

    it('calls onReload when update response has no data', async () => {
      const mockOnReload = vi.fn()
      mockApi.put.mockResolvedValue({}) // No data
      
      render(<ReviewsList {...defaultProps} onReload={mockOnReload} />)
      
      const editButton = screen.getAllByText('Edit')[0]
      fireEvent.click(editButton)

      await waitFor(() => {
        const saveButton = screen.getByText('Save')
        fireEvent.click(saveButton)
      })

      expect(mockOnReload).toHaveBeenCalled()
    })
  })

  describe('Unauthenticated Users', () => {
    beforeEach(() => {
      mockUseAuth.mockReturnValue({ user: null })
    })

    it('does not show edit/delete buttons for unauthenticated users', () => {
      render(<ReviewsList {...defaultProps} />)
      
      expect(screen.queryByText('Edit')).not.toBeInTheDocument()
      expect(screen.queryByText('Delete')).not.toBeInTheDocument()
    })
  })
})