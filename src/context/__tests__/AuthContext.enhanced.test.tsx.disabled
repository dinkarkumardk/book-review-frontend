import { render, screen, waitFor, act } from '@testing-library/react';
import { vi, describe, it, expect, beforeEach } from 'vitest';
import { AuthProvider, useAuth } from '../AuthContext';

// Mock dependencies
const mockApi = {
  defaults: { headers: { common: {} as any } },
  get: vi.fn()
};

vi.mock('@/services/api', () => ({
  default: mockApi
}));

const mockToast = {
  success: vi.fn(),
  error: vi.fn()
};

vi.mock('react-hot-toast', () => ({
  default: mockToast
}));

// Mock localStorage
const mockLocalStorage = {
  getItem: vi.fn(),
  setItem: vi.fn(),
  removeItem: vi.fn(),
  clear: vi.fn()
};
Object.defineProperty(window, 'localStorage', {
  value: mockLocalStorage,
  writable: true
});

// Test component to use the auth context
const TestComponent = () => {
  const { user, token, initializing, login, logout, refreshUser } = useAuth();
  
  return (
    <div>
      <div data-testid="user">{user ? JSON.stringify(user) : 'No user'}</div>
      <div data-testid="token">{token || 'No token'}</div>
      <div data-testid="initializing">{initializing ? 'Initializing' : 'Ready'}</div>
      <button onClick={() => login('test-token', { id: '1', name: 'Test', email: 'test@example.com' })}>
        Login
      </button>
      <button onClick={logout}>Logout</button>
      <button onClick={refreshUser}>Refresh</button>
    </div>
  );
};

const renderWithAuthProvider = () => {
  return render(
    <AuthProvider>
      <TestComponent />
    </AuthProvider>
  );
};

describe('AuthContext', () => {
  beforeEach(() => {
    vi.clearAllMocks();
    mockLocalStorage.getItem.mockReturnValue(null);
  });

  describe('Provider Setup', () => {
    it('provides initial auth state when no stored token', async () => {
      renderWithAuthProvider();
      
      await waitFor(() => {
        expect(screen.getByTestId('user')).toHaveTextContent('No user');
        expect(screen.getByTestId('token')).toHaveTextContent('No token');
        expect(screen.getByTestId('initializing')).toHaveTextContent('Ready');
      });
    });

    it('attempts to restore session from localStorage', async () => {
      const mockToken = 'stored-token';
      const mockUser = { id: '1', name: 'Stored User', email: 'stored@example.com' };
      
      mockLocalStorage.getItem
        .mockReturnValueOnce(mockToken) // TOKEN_KEY
        .mockReturnValueOnce(JSON.stringify(mockUser)); // USER_KEY
      
      mockApi.get.mockResolvedValue({ data: mockUser });
      
      renderWithAuthProvider();
      
      await waitFor(() => {
        expect(screen.getByTestId('initializing')).toHaveTextContent('Ready');
      });
      
      expect(mockApi.defaults.headers.common['Authorization']).toBe(`Bearer ${mockToken}`);
    });

    it('handles invalid stored user data', async () => {
      mockLocalStorage.getItem
        .mockReturnValueOnce('token')
        .mockReturnValueOnce('invalid-json');
      
      renderWithAuthProvider();
      
      await waitFor(() => {
        expect(screen.getByTestId('initializing')).toHaveTextContent('Ready');
        expect(screen.getByTestId('user')).toHaveTextContent('No user');
      });
    });

    it('handles API error during session restoration', async () => {
      mockLocalStorage.getItem.mockReturnValueOnce('invalid-token');
      mockApi.get.mockRejectedValue(new Error('Unauthorized'));
      
      renderWithAuthProvider();
      
      await waitFor(() => {
        expect(screen.getByTestId('initializing')).toHaveTextContent('Ready');
        expect(screen.getByTestId('user')).toHaveTextContent('No user');
      });
      
      expect(mockLocalStorage.removeItem).toHaveBeenCalledWith('auth_token');
      expect(mockLocalStorage.removeItem).toHaveBeenCalledWith('auth_user');
    });
  });

  describe('Authentication Actions', () => {
    it('handles login correctly', async () => {
      renderWithAuthProvider();
      
      await waitFor(() => {
        expect(screen.getByTestId('initializing')).toHaveTextContent('Ready');
      });
      
      const loginButton = screen.getByText('Login');
      act(() => {
        loginButton.click();
      });
      
      await waitFor(() => {
        expect(screen.getByTestId('token')).toHaveTextContent('test-token');
        expect(screen.getByTestId('user')).toHaveTextContent('Test');
      });
      
      expect(mockLocalStorage.setItem).toHaveBeenCalledWith('auth_token', 'test-token');
      expect(mockLocalStorage.setItem).toHaveBeenCalledWith('auth_user', expect.any(String));
      expect(mockApi.defaults.headers.common['Authorization']).toBe('Bearer test-token');
    });

    it('handles logout correctly', async () => {
      renderWithAuthProvider();
      
      // First login
      await waitFor(() => {
        expect(screen.getByTestId('initializing')).toHaveTextContent('Ready');
      });
      
      const loginButton = screen.getByText('Login');
      act(() => {
        loginButton.click();
      });
      
      await waitFor(() => {
        expect(screen.getByTestId('user')).not.toHaveTextContent('No user');
      });
      
      // Then logout
      const logoutButton = screen.getByText('Logout');
      act(() => {
        logoutButton.click();
      });
      
      await waitFor(() => {
        expect(screen.getByTestId('user')).toHaveTextContent('No user');
        expect(screen.getByTestId('token')).toHaveTextContent('No token');
      });
      
      expect(mockLocalStorage.removeItem).toHaveBeenCalledWith('auth_token');
      expect(mockLocalStorage.removeItem).toHaveBeenCalledWith('auth_user');
      expect(mockApi.defaults.headers.common['Authorization']).toBeUndefined();
    });

    it('handles user refresh successfully', async () => {
      const updatedUser = { id: '1', name: 'Updated User', email: 'updated@example.com' };
      mockApi.get.mockResolvedValue({ data: updatedUser });
      
      renderWithAuthProvider();
      
      // Login first
      await waitFor(() => {
        expect(screen.getByTestId('initializing')).toHaveTextContent('Ready');
      });
      
      const loginButton = screen.getByText('Login');
      act(() => {
        loginButton.click();
      });
      
      await waitFor(() => {
        expect(screen.getByTestId('user')).toHaveTextContent('Test');
      });
      
      // Refresh user
      const refreshButton = screen.getByText('Refresh');
      act(() => {
        refreshButton.click();
      });
      
      await waitFor(() => {
        expect(screen.getByTestId('user')).toHaveTextContent('Updated User');
      });
      
      expect(mockApi.get).toHaveBeenCalledWith('/auth/me');
      expect(mockLocalStorage.setItem).toHaveBeenCalledWith('auth_user', JSON.stringify(updatedUser));
    });

    it('handles refresh error when not logged in', async () => {
      renderWithAuthProvider();
      
      await waitFor(() => {
        expect(screen.getByTestId('initializing')).toHaveTextContent('Ready');
      });
      
      const refreshButton = screen.getByText('Refresh');
      act(() => {
        refreshButton.click();
      });
      
      // Should not make API call when not logged in
      expect(mockApi.get).not.toHaveBeenCalled();
    });

    it('handles refresh API error', async () => {
      mockApi.get.mockRejectedValue(new Error('Server error'));
      
      renderWithAuthProvider();
      
      // Login first
      await waitFor(() => {
        expect(screen.getByTestId('initializing')).toHaveTextContent('Ready');
      });
      
      const loginButton = screen.getByText('Login');
      act(() => {
        loginButton.click();
      });
      
      await waitFor(() => {
        expect(screen.getByTestId('user')).toHaveTextContent('Test');
      });
      
      // Refresh user
      const refreshButton = screen.getByText('Refresh');
      act(() => {
        refreshButton.click();
      });
      
      await waitFor(() => {
        expect(mockToast.error).toHaveBeenCalledWith('Failed to refresh user data');
      });
    });
  });

  describe('Error Handling', () => {
    it('throws error when useAuth is used outside provider', () => {
      const TestComponentOutsideProvider = () => {
        const auth = useAuth();
        return <div>{auth.user?.name}</div>;
      };
      
      // Suppress console.error for this test
      const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {});
      
      expect(() => {
        render(<TestComponentOutsideProvider />);
      }).toThrow('useAuth must be used within an AuthProvider');
      
      consoleSpy.mockRestore();
    });

    it('handles localStorage errors gracefully', async () => {
      mockLocalStorage.getItem.mockImplementation(() => {
        throw new Error('LocalStorage error');
      });
      
      renderWithAuthProvider();
      
      await waitFor(() => {
        expect(screen.getByTestId('initializing')).toHaveTextContent('Ready');
      });
    });
  });

  describe('State Management', () => {
    it('maintains consistent state during operations', async () => {
      renderWithAuthProvider();
      
      await waitFor(() => {
        expect(screen.getByTestId('initializing')).toHaveTextContent('Ready');
      });
      
      // Verify initial state
      expect(screen.getByTestId('user')).toHaveTextContent('No user');
      expect(screen.getByTestId('token')).toHaveTextContent('No token');
      
      // Login
      const loginButton = screen.getByText('Login');
      act(() => {
        loginButton.click();
      });
      
      await waitFor(() => {
        expect(screen.getByTestId('user')).toHaveTextContent('Test');
        expect(screen.getByTestId('token')).toHaveTextContent('test-token');
      });
      
      // Logout
      const logoutButton = screen.getByText('Logout');
      act(() => {
        logoutButton.click();
      });
      
      await waitFor(() => {
        expect(screen.getByTestId('user')).toHaveTextContent('No user');
        expect(screen.getByTestId('token')).toHaveTextContent('No token');
      });
    });
  });
});